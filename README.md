&nbsp;&nbsp;&nbsp;&nbsp;`POST: /order` - a list of dishes that comprise a order to be ordered. This method would take in the restaurant's name and a list of orders that the user wants to place. First, we check if there any of those dishes left to be ordered, ie. we check if the inventory is not empty, then we subtract one from the inventory and move the dish to the trending database, which I will explain further below. This operation updating the inventory and moving to the trending list involves asynchronous method calls, so I gather them together and let them all run at the same time as a singular batch.

&nbsp;&nbsp;&nbsp;&nbsp;`GET: /restaurants` - show the list of existing restaurants in the database. This method returns all the restaurants in the database as Restaurant objects and nothing more. Returning the restaurant and its food items would be inefficient, as the user would only have to load data for the restaurant that they want to buy food from, therefore we prevent loading unnecessary data. This explains the existence of the next API call.

&nbsp;&nbsp;&nbsp;&nbsp;`GET: /availableFood` - show the list of food in the restaurant that the user navigated to. This method takes in the name of the restaurant from which to fetch the food that is available and returns a list of Dish objects.

&nbsp;&nbsp;&nbsp;&nbsp;`GET: /trending` - get a list of the current trending items. This method shows the trending food items. There are a few components to this method. First the heuristic that we use is a simple sum of the timestamps of when the user bought a certain item. Every time the user orders a food item, that item is registed in the trending database as mentioned above. Depending on the number of food items ordered, that many number of timestamps of when the food item was ordered is appended to a list of timestamps for that food item in the trending database. Then, while fetching the data, we simply fetch all the timestamps for that food item and determine how many were bought by finding the length of the timestamps array. The timestamps are then sorted in descending order, as the largest timestamp is the furthest away from epoch time which is the closest to current time. This way, we are able to tell when the most recent buy was. Now, the question is how do we figure out which is the most trending and which is the least trending. We determine a simple heuristic based on number of items bought and when they were bought. This can simply be the sum of all the timestamps that we collected as previously described. Because the overflow number is too large in comparison to the value of a timestamp value relative to the time at the moment, we ignore how large the numbers could be. The hueristic is as follows: `H(x) = Î£ (T(y)), where T is the function that returns the timestamp for a product at index y in the timestamps array.` Then we proceed to sort an array of the dishes with the trend score in descending order and return it. There is a catch though, as only foods have been bought in the last 48 hours can be shown, so every time the `/trending` endpiont is called, we run a `cleanse()` function that cleanses the timestamps by removing them if they are over 2 days ago. 
